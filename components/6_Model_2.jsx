/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/model_2/model_2.glb 
*/
import * as THREE from 'three';
import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useTexture } from '@react-three/drei'
import gsap from 'gsap';
import { CameraControls, Loader, OrbitControls, PerspectiveCamera, useProgress } from '@react-three/drei';
import {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';
import { useFrame, useLoader } from '@react-three/fiber';
import { vertexShader,_fragmentShader,vertexShader2,_fragmentShader2 } from './shaders';

export function Model_2(props) {
  
  const { nodes, materials } = useGLTF('/model_2.glb');
  const hdrtexture = useLoader(RGBELoader, "/hdr3.hdr");
    hdrtexture.mapping = THREE.EquirectangularReflectionMapping;
  let [modelTxtSrc,poseTxtSrc,model2TxtSrc,model3TxtSrc,
    recade1TxtSrc,recade2TxtSrc,recade3TxtSrc,sceneTxtSrc,recadeSocleTxtSrc,
    behanzineTxtSrc,descAfficheTxtSrc_1,descAfficheTxtSrc_2,descAfficheTxtSrc_0,tronetxtSrc,troneSocletxtSrc,troneBartxtSrc] = useTexture(['/model_2/stat1_txt.jpg','/model_2/pose.jpg','/model_2/stat2_txt.jpg',
                                                              '/model_2/stat3_txt.jpg','/model_2/recade_1_txt.jpg','/model_2/recade_2_txt.jpg',
                                                              '/model_2/recade_3_txt.jpg','/model_2/scenetxt.jpg','/model_2/recadeSocletxt.jpg',
                                                              '/model_2/Behanzin-png.png','/model_2/affiche_2.png','/model_2/affiche_3.png',
                                                              '/model_2/affiche_0.png','/model_2/troneTXT.jpg','model_2/socletxt1.jpg',
                                                              'model_2/masktxt_new_1.jpg']);
  
  let txtarray = [modelTxtSrc,poseTxtSrc,model2TxtSrc,model3TxtSrc,recade1TxtSrc,recade2TxtSrc,recade3TxtSrc,sceneTxtSrc,recadeSocleTxtSrc,
    behanzineTxtSrc,descAfficheTxtSrc_1,descAfficheTxtSrc_2,descAfficheTxtSrc_0,tronetxtSrc,troneSocletxtSrc,troneBartxtSrc];
  for(let i =0;i< txtarray.length;i++)
  {
    txtarray[i].flipY = false;
    txtarray[i].colorSpace = THREE.SRGBColorSpace; 
    txtarray[i].minFilter = THREE.LinearFilter;
    txtarray[i].magFilter = THREE.LinearFilter;
  }
  let uniform2 = useRef(
    {
      utime:{value:0.0}
    }
    )



  // let model_1txt = useRef(new THREE.MeshBasicMaterial({map:modelTxtSrc}));
  // let model_2txt = useRef(new THREE.MeshBasicMaterial({map:model2TxtSrc}));
  // let model_3txt = useRef(new THREE.MeshBasicMaterial({map:model3TxtSrc}));
  // let pose_1txt = useRef(new THREE.MeshBasicMaterial({map:poseTxtSrc}));

  let recade_1txt = useRef(new THREE.MeshBasicMaterial({map:recade1TxtSrc}));
  let recade_2txt = useRef(new THREE.MeshBasicMaterial({map:recade2TxtSrc}));
  let recade_3txt = useRef(new THREE.MeshBasicMaterial({map:recade3TxtSrc}));
  let scene_txt = useRef(new THREE.MeshBasicMaterial({map:sceneTxtSrc}));
  let recadeSocle_txt = useRef(new THREE.MeshBasicMaterial({map:recadeSocleTxtSrc}));
  let recadeGlass_txt = useRef(new THREE.MeshPhysicalMaterial({transmission:1,roughness:0,metalness:0,ior:1,envMap:hdrtexture}));
  let portrait_txt = useRef(new THREE.MeshBasicMaterial({map:behanzineTxtSrc}));
  let desc0_txt = useRef(new THREE.MeshBasicMaterial({map:descAfficheTxtSrc_0}));
  let desc1_txt = useRef(new THREE.MeshBasicMaterial({map:descAfficheTxtSrc_1}));
  let desc2_txt = useRef(new THREE.MeshBasicMaterial({map:descAfficheTxtSrc_2}));
  let trone_txt = useRef(new THREE.MeshBasicMaterial({map:tronetxtSrc}));
  let troneSocle_txt = useRef(new THREE.MeshBasicMaterial({map:troneSocletxtSrc}));
  let troneBar_txt = useRef(new THREE.MeshBasicMaterial({map:troneBartxtSrc}));
  let deselect_txt = useRef(new THREE.ShaderMaterial({ side:THREE.BackSide, vertexShader:vertexShader2,fragmentShader:_fragmentShader2,uniforms:uniform2.current}));

  let model_1txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  let model_2txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  let model_3txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  let pose_1txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));

  // let recade_1txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  // let recade_2txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  // let recade_3txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  // let scene_txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  // let recadeSocle_txt = useRef(new THREE.MeshBasicMaterial({color:'white',wireframe:true}));
  useFrame((state,delta)=>
  {

        deselect_txt.current.uniforms.utime.value += 0.03;
        
  })
  return (
    <>
    <group {...props} dispose={null}>
      <group position={[-102.97, 14.019, -22.926]}>
        <primitive object={nodes.Bone} />
        <primitive object={nodes.Bone022L} />
        <primitive object={nodes.Bone023L} />
        <primitive object={nodes.Bone022R} />
        <primitive object={nodes.Bone023R} />
        <skinnedMesh geometry={nodes.model_template_1002.geometry} material={nodes.model_template_1002.material} skeleton={nodes.model_template_1002.skeleton} />
      </group>
      <group position={[-85.893, 13.905, -32.539]} rotation={[0, 0.441, 0]}>
        <primitive object={nodes.Bone_1} />
        <primitive object={nodes.Bone022L_1} />
        <primitive object={nodes.Bone023L_1} />
        <primitive object={nodes.Bone022R_1} />
        <primitive object={nodes.Bone023R_1} />
        <skinnedMesh geometry={nodes.body_2.geometry} material={nodes.body_2.material} skeleton={nodes.body_2.skeleton} />
      </group>
      <group position={[-116.233, 14.145, -34.014]} rotation={[0, -0.458, 0]}>
        <primitive object={nodes.Bone_2} />
        <primitive object={nodes.Bone022L_2} />
        <primitive object={nodes.Bone023L_2} />
        <primitive object={nodes.Bone022R_2} />
        <primitive object={nodes.Bone023R_2} />
        <skinnedMesh geometry={nodes.body_3.geometry} material={nodes.body_3.material} skeleton={nodes.body_3.skeleton} />
      </group>
      <mesh geometry={nodes.posesocle.geometry} material={nodes.posesocle.material} position={[-111.254, 6.995, -30.365]} />
      <mesh geometry={nodes.armring.geometry} material={nodes.armring.material} position={[-101.768, 15.058, -23.207]} rotation={[0, 0, -1.187]} />
      <mesh geometry={nodes.belt.geometry} material={nodes.belt.material} position={[-102.945, 13.803, -22.992]} />
      <mesh geometry={nodes.head.geometry} material={nodes.head.material} position={[-102.997, 17.067, -22.979]} />
      <mesh geometry={nodes.neck.geometry} material={nodes.neck.material} position={[-103.009, 16.619, -23.148]} />
      <mesh geometry={nodes.pose.geometry} material={nodes.pose.material} position={[-102.933, 9.325, -22.507]} />
      <mesh geometry={nodes.pose_2.geometry} material={nodes.pose_2.material} position={[-85.816, 9.325, -32.437]} rotation={[0, 0.441, 0]} />
      <mesh geometry={nodes.head_2.geometry} material={nodes.head_2.material} position={[-85.836, 16.801, -32.316]} rotation={[0, 0.441, 0]} scale={[0.75, 1, 1]} />
      <mesh geometry={nodes.wing_2.geometry} material={nodes.wing_2.material} position={[-85.989, 15.189, -32.716]} rotation={[0, 0.441, 0]} />
      <mesh geometry={nodes.head__3.geometry} material={nodes.head__3.material} position={[-116.319, 17.671, -33.977]} rotation={[0, -0.458, 0]} />
      <mesh geometry={nodes.tail_3.geometry} material={nodes.tail_3.material} position={[-115.664, 13.296, -35.091]} rotation={[-Math.PI / 2, 0, -0.458]} />
      <mesh geometry={nodes.belt_3.geometry} material={nodes.belt_3.material} position={[-116.491, 13.211, -33.477]} rotation={[-0.248, -0.446, -0.109]} />
      <mesh geometry={nodes.pose_3.geometry} material={nodes.pose_3.material} position={[-116.575, 9.413, -33.249]} rotation={[0, -0.458, 0]} />
      <mesh geometry={nodes.recade_2.geometry} material={recade_2txt.current} position={[35.388, 18.062, 5.282]} rotation={[-1.938, -0.085, -3.072]} />
      <mesh geometry={nodes.recade_1.geometry} material={recade_1txt.current} position={[-14.415, 17.8, -38.974]} rotation={[-1.527, -0.368, -1.555]} />
      <mesh geometry={nodes.recade_3.geometry} material={recade_3txt.current} position={[32.329, 18.549, -33.228]} rotation={[-1.814, -0.294, -2.366]} />
      <mesh geometry={nodes.recadeGlass_2.geometry} material={recadeGlass_txt.current} position={[34.947, 18.358, 2.968]} rotation={[0, -1.571, 0]} />
      <mesh geometry={nodes.recadeGlass_3.geometry} material={recadeGlass_txt.current} position={[29.844, 18.358, -34.896]} rotation={[0, -Math.PI / 4, 0]} />
      <mesh geometry={nodes.recadesocle_2.geometry} material={recadeSocle_txt.current} position={[34.951, 8.543, 2.957]} rotation={[0, -1.571, 0]} />
      <mesh geometry={nodes.recadesocle_3.geometry} material={recadeSocle_txt.current} position={[29.839, 8.543, -34.906]} rotation={[0, -Math.PI / 4, 0]} />
      <mesh geometry={nodes.recadevitrebar_2.geometry} material={nodes.recadevitrebar_2.material} position={[34.951, 21.254, 2.957]} rotation={[0, -1.571, 0]} />
      <mesh geometry={nodes.recadevitrebar_3.geometry} material={nodes.recadevitrebar_3.material} position={[29.839, 21.254, -34.906]} rotation={[0, -Math.PI / 4, 0]} />
      <mesh geometry={nodes.recadesocle_1.geometry} material={recadeSocle_txt.current} position={[-16.259, 8.543, -38.083]} />
      <mesh geometry={nodes.recadevitrebar_1.geometry} material={nodes.recadevitrebar_1.material} position={[-16.259, 21.254, -38.083]} />
      <mesh geometry={nodes.recadeGlass_1.geometry} material={recadeGlass_txt.current} position={[-16.248, 18.358, -38.08]} />
      <mesh geometry={nodes.wall.geometry} material={scene_txt.current} position={[-40, 2.113, 0]} />
      <mesh geometry={nodes.ground.geometry} material={scene_txt.current} position={[-40, 2.113, 0]} />
      <mesh geometry={nodes.groundwall.geometry} material={scene_txt.current} position={[-40, 2.113, 0]} />
      <mesh geometry={nodes.plafond.geometry} material={scene_txt.current} position={[-78.154, 51.631, 0.058]} scale={0.3} />
      <mesh geometry={nodes.affiche_1.geometry} material={nodes.affiche_1.material} position={[-98.857, 21.273, -59.831]} />
      <mesh geometry={nodes.affiche_0_img.geometry} material={desc0_txt.current} position={[-98.857, 21.273, -59.831]} />
      <mesh geometry={nodes.affiche_1_img.geometry} scale={1} material={portrait_txt.current} position={[-98.857, 21.273, -59.831]} />
      <mesh geometry={nodes.affiche_2_img.geometry} material={desc1_txt.current} position={[-98.857, 21.273, -59.831]} />
      <mesh geometry={nodes.affiche_3_img.geometry} material={desc2_txt.current} position={[-98.857, 21.273, -59.831]} />
      <mesh geometry={nodes.bar2.geometry} material={troneBar_txt.current} position={[-187.659, 10.952, -21.185]} />
      <mesh geometry={nodes.desc.geometry} material={troneSocle_txt.current} position={[-195.346, 10.349, -29.344]} rotation={[-0.41, -0.508, -0.208]} />
      <mesh geometry={nodes.descselect.geometry} material={deselect_txt.current} position={[-195.111, 10.234, -29.351]} rotation={[-0.41, -0.508, -0.208]} />
      <mesh geometry={nodes.pied2.geometry} material={troneSocle_txt.current} position={[-187.544, 5.763, -36.913]} />
      <mesh geometry={nodes.trone.geometry} material={trone_txt.current} position={[-187.437, 17.493, -35.568]} />

    </group>
    

   
    </>
  )
}


export function CameraCompo_2(props)
{
        const { nodes } = useGLTF('/model_2.glb');
        let camref = useRef(null);
        let orbitref = useRef(null);
        let activateOnce = useRef(false);
        let cameraPosition =[{x:nodes.campose_0.position.x,y:nodes.campose_0.position.y,z:nodes.campose_0.position.z+10},
                            {x:nodes.campose_1.position.x,y:nodes.campose_1.position.y,z:nodes.campose_1.position.z},
                            {x:nodes.campose_2.position.x,y:nodes.campose_2.position.y,z:nodes.campose_2.position.z}];
        let cameraLook=[{x:nodes.camlook_0.position.x,y:nodes.camlook_0.position.y,z:nodes.camlook_0.position.z}
                        ,{x:nodes.camlook_1.position.x,y:nodes.camlook_1.position.y,z:nodes.camlook_1.position.z},{x:nodes.camlook_2.position.x,y:nodes.camlook_2.position.y,z:nodes.camlook_2.position.z}];
        let actualCamIndex = useRef(0);
        let actualCamPos = [cameraPosition[1].x,cameraPosition[1].y,cameraPosition[1].z];

        let setCampose = ()=>
        {
       
          //orbitref.current.minDistance=50   //ZOOMIN
          // orbitref.current.maxDistance=1500
          orbitref.current.maxAzimuthAngle = Math.PI*(1.4)+4;  //rotation droite
          orbitref.current.minAzimuthAngle = Math.PI*(0.6)+3;
          // orbitref.current.rotateSpeed = 0.2
          orbitref.current.maxPolarAngle=1.7 // rotation verticale MAXI
            actualCamIndex.current = props.actualIndex;

            
                  gsap.to(camref.current.position, 
                  { x: cameraPosition[actualCamIndex.current].x,
                    y: cameraPosition[actualCamIndex.current].y,
                    z: cameraPosition[actualCamIndex.current].z,
                    duration: 1,
                    onComplete:()=>
                    {
                      
                      
                    } });
                    gsap.to(orbitref.current.target, 
                      { x: cameraLook[actualCamIndex.current].x,
                        y: cameraLook[actualCamIndex.current].y,
                        z: cameraLook[actualCamIndex.current].z,
                        duration: 1,
                        onComplete:()=>
                        {
                          
                          
                        } });
        }
        
        useEffect(()=>
        {

          setCampose();

        },[props.actualIndex])
        return  <>
                   
                   
                   <PerspectiveCamera ref={camref} position={actualCamPos}   makeDefault   />
                   <OrbitControls maxDistance={50} minDistance={30} 
                   maxAzimuthAngle ={ Math.PI*(1.4)+4} minAzimuthAngle = {Math.PI*(0.6)+3} maxPolarAngle={1.7} 
                   ref={orbitref} target={[nodes.camlook_0.position.x,nodes.camlook_0.position.y,nodes.camlook_0.position.z]} />
                   
                   

                </>

}
useGLTF.preload('/model_2.glb');
