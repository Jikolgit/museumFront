/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/musee.glb 
*/

import React, { useContext, useEffect, useRef } from 'react'
import { useGLTF, useTexture } from '@react-three/drei';
import * as THREE from 'three';
import { useFrame, useLoader } from '@react-three/fiber';
import {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';
import { menuContexte } from '@/pages/visite';


export function Model(props) {
  let valContext = useContext(menuContexte);

  let glassBoxRef = useRef(null);
  let glassRef = useRef(null);
  let maskRef = useRef(null);
  let EnanblemaskRotation = useRef(false);
  const { nodes, materials } = useGLTF('/musee.glb');
  let vertexShader = `
 
 
  
  
 
  varying vec2 vUv;
  
  void main() {
   
    vec3 newPosition = position ;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
    vUv = uv;
  }`;
  let _fragmentShader = `
  varying vec2 vUv;
  
  
  
    void main() {
      
      gl_FragColor = vec4(vUv,0.5,1.0);
  
    }  
  `;
  let [plafondtxtSrc,wallGroundtxtSrc,maskTxtSrc,piedTxtSrc,tronetxtSrc,socletxtSrc,tamtamtxtSrc1,tamtamtxtSrc2] = 
  useTexture(["/plafondtxt.jpg",'/scenetxt2.jpg','/masktxt_new_1.jpg','/piedtxt.jpg','/troneTXT.jpg','/socletxt1.jpg','tamtxt.jpg','tamtxt_2.jpg']);
  let txtarray = [plafondtxtSrc,wallGroundtxtSrc,maskTxtSrc,piedTxtSrc,tronetxtSrc,socletxtSrc,tamtamtxtSrc1,tamtamtxtSrc2];
  for(let i =0;i< txtarray.length;i++)
  {
    txtarray[i].flipY = false;
    txtarray[i].colorSpace = THREE.SRGBColorSpace; 
    txtarray[i].minFilter = THREE.LinearFilter;
    txtarray[i].magFilter = THREE.LinearFilter;
  }
  const hdrtexture = useLoader(RGBELoader, "/hdr3.hdr");
  hdrtexture.mapping = THREE.EquirectangularReflectionMapping;
  let glasstxt = new THREE.MeshPhysicalMaterial({transmission:1,roughness:0,metalness:0,ior:1,envMap:hdrtexture});
  let maskCubetxt = new THREE.MeshBasicMaterial({visible:false,transparent:true});
  let plafondtxt = new THREE.MeshBasicMaterial({map:plafondtxtSrc});
  let wallgroundtxt = new THREE.MeshBasicMaterial({map:wallGroundtxtSrc});
  let masktxt = new THREE.MeshBasicMaterial({map:maskTxtSrc});
  let fronttxt = new THREE.ShaderMaterial({vertexShader:vertexShader,fragmentShader:_fragmentShader});
  let piedtxt = new THREE.MeshBasicMaterial({map:piedTxtSrc});
  let tronetxt = new THREE.MeshBasicMaterial({map:tronetxtSrc});
  let glassBartxt = new THREE.MeshBasicMaterial({map:tronetxtSrc});
  let socletxt = new THREE.MeshBasicMaterial({map:socletxtSrc});
  let deselectTxt = new THREE.MeshBasicMaterial({visible:false,transparent:true});
  let tamtamtxt_1 = new THREE.MeshBasicMaterial({map:tamtamtxtSrc1});
  let tamtamtxt_2 = new THREE.MeshBasicMaterial({map:tamtamtxtSrc2});

  // let glasstxt = new THREE.MeshPhysicalMaterial({color:'white',wireframe:true});
  // let maskCubetxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let plafondtxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let wallgroundtxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let masktxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let fronttxt = new THREE.ShaderMaterial({vertexShader:vertexShader,fragmentShader:_fragmentShader});
  // let piedtxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let tronetxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let glassBartxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let socletxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let deselectTxt = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let tamtamtxt_1 = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  // let tamtamtxt_2 = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  useEffect(()=>
  {
   
    if(valContext.removeGlass)
    {
          glassBoxRef.current.material.visible = false;
          glassRef.current.material.visible = false;
    }
    else
    {
          glassBoxRef.current.material.visible = true;
          glassRef.current.material.visible = true;
    }

    if(valContext.rotateModel)
    {
      EnanblemaskRotation.current = true;
    }
    else
    {
      EnanblemaskRotation.current = false;
    }
  },[valContext.removeGlass,valContext.rotateModel])

  useFrame((state,deltat)=>
  {
        if(EnanblemaskRotation.current)
        {
          maskRef.current.rotation.y += 0.01;
        }
  })
  let showInfo_1 = ()=>
  {
    valContext.setshowInfo_1(c=> c = !valContext.showInfo_1)
  }
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.pied.geometry} material={piedtxt} position={[-41.033, 0.015, -27.952]} />
      <mesh geometry={nodes.trone.geometry} material={tronetxt} position={[-14.503, 2.033, -26.188]} />
      <mesh ref={glassRef} geometry={nodes.glass.geometry} material={glasstxt} position={[-41.179, 6.567, -28.002]} />
      <mesh geometry={nodes.bar.geometry} material={masktxt} position={[-41.049, 2.986, -25.205]} />
      <mesh ref={glassBoxRef} geometry={nodes.glassbar.geometry} material={glassBartxt} position={[-41.029, 6.293, -27.971]} />
      <mesh geometry={nodes.scene.geometry} material={wallgroundtxt} position={[0.01, 0.044, 0.044]} />
      <mesh geometry={nodes.pied2.geometry} material={socletxt} position={[-14.543, 1.078, -26.219]} />
      <mesh geometry={nodes.bar2.geometry} material={masktxt} position={[-14.585, 2.986, -20.437]} />
      <mesh onClick={showInfo_1} geometry={nodes.desc.geometry} material={socletxt} position={[-17.31, 2.712, -23.462]} rotation={[-0.41, -0.508, -0.208]} />
      <mesh geometry={nodes.descselect.geometry} material={deselectTxt} position={[-17.31, 2.712, -23.462]} rotation={[-0.41, -0.508, -0.208]} />
      <mesh geometry={nodes.tamtam_1.geometry} material={tamtamtxt_1} position={[13.529, 2.612, -22.799]} />
      <mesh geometry={nodes.tamtam_2.geometry} material={tamtamtxt_2} position={[19.813, 5.632, -23.939]} scale={1.413} />
      <mesh geometry={nodes.tamtam_2_1.geometry} material={tamtamtxt_2} position={[7.293, 4.327, -26.362]} rotation={[0.972, -0.358, 0.475]} scale={1.413} />
      <mesh ref={maskRef} geometry={nodes.maskCube.geometry} material={maskCubetxt} position={[-41.034, 6.114, -27.974]}>
        <mesh geometry={nodes.cap_new.geometry} material={masktxt} position={[0.007, 0.359, 0.019]} />
        <mesh geometry={nodes.ears_new.geometry} material={masktxt} position={[0.006, 0.03, -0.285]} />
        <mesh geometry={nodes.face_new.geometry} material={masktxt} position={[0.006, -0.198, 0.095]} />
        <mesh  geometry={nodes.front_new.geometry} material={fronttxt} position={[0.011, 0.53, 0.1]} rotation={[-0.083, 0, 0]} scale={0.797} />
      </mesh>
      <mesh geometry={nodes.plafond.geometry} material={plafondtxt} position={[-0.127, 31.974, 0.044]} />
      
    </group>
  )
}


useGLTF.preload('/musee.glb')
